// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: esp_local_ctrl.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum LocalCtrlMsgType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case typeCmdGetPropertyCount // = 0
    case typeRespGetPropertyCount // = 1
    case typeCmdGetPropertyValues // = 4
    case typeRespGetPropertyValues // = 5
    case typeCmdSetPropertyValues // = 6
    case typeRespSetPropertyValues // = 7
    case UNRECOGNIZED(Int)

    init() {
        self = .typeCmdGetPropertyCount
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .typeCmdGetPropertyCount
        case 1: self = .typeRespGetPropertyCount
        case 4: self = .typeCmdGetPropertyValues
        case 5: self = .typeRespGetPropertyValues
        case 6: self = .typeCmdSetPropertyValues
        case 7: self = .typeRespSetPropertyValues
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .typeCmdGetPropertyCount: return 0
        case .typeRespGetPropertyCount: return 1
        case .typeCmdGetPropertyValues: return 4
        case .typeRespGetPropertyValues: return 5
        case .typeCmdSetPropertyValues: return 6
        case .typeRespSetPropertyValues: return 7
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension LocalCtrlMsgType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [LocalCtrlMsgType] = [
            .typeCmdGetPropertyCount,
            .typeRespGetPropertyCount,
            .typeCmdGetPropertyValues,
            .typeRespGetPropertyValues,
            .typeCmdSetPropertyValues,
            .typeRespSetPropertyValues,
        ]
    }

#endif // swift(>=4.2)

struct CmdGetPropertyCount {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct RespGetPropertyCount {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Status = .success

    var count: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct PropertyInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Status = .success

    var name = String()

    var type: UInt32 = 0

    var flags: UInt32 = 0

    var value: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct CmdGetPropertyValues {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var indices: [UInt32] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct RespGetPropertyValues {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Status = .success

    var props: [PropertyInfo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct PropertyValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 = 0

    var value: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct CmdSetPropertyValues {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var props: [PropertyValue] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct RespSetPropertyValues {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Status = .success

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct LocalCtrlMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var msg: LocalCtrlMsgType {
        get { return _storage._msg }
        set { _uniqueStorage()._msg = newValue }
    }

    var payload: OneOf_Payload? {
        get { return _storage._payload }
        set { _uniqueStorage()._payload = newValue }
    }

    var cmdGetPropCount: CmdGetPropertyCount {
        get {
            if case let .cmdGetPropCount(v)? = _storage._payload { return v }
            return CmdGetPropertyCount()
        }
        set { _uniqueStorage()._payload = .cmdGetPropCount(newValue) }
    }

    var respGetPropCount: RespGetPropertyCount {
        get {
            if case let .respGetPropCount(v)? = _storage._payload { return v }
            return RespGetPropertyCount()
        }
        set { _uniqueStorage()._payload = .respGetPropCount(newValue) }
    }

    var cmdGetPropVals: CmdGetPropertyValues {
        get {
            if case let .cmdGetPropVals(v)? = _storage._payload { return v }
            return CmdGetPropertyValues()
        }
        set { _uniqueStorage()._payload = .cmdGetPropVals(newValue) }
    }

    var respGetPropVals: RespGetPropertyValues {
        get {
            if case let .respGetPropVals(v)? = _storage._payload { return v }
            return RespGetPropertyValues()
        }
        set { _uniqueStorage()._payload = .respGetPropVals(newValue) }
    }

    var cmdSetPropVals: CmdSetPropertyValues {
        get {
            if case let .cmdSetPropVals(v)? = _storage._payload { return v }
            return CmdSetPropertyValues()
        }
        set { _uniqueStorage()._payload = .cmdSetPropVals(newValue) }
    }

    var respSetPropVals: RespSetPropertyValues {
        get {
            if case let .respSetPropVals(v)? = _storage._payload { return v }
            return RespSetPropertyValues()
        }
        set { _uniqueStorage()._payload = .respSetPropVals(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Payload: Equatable {
        case cmdGetPropCount(CmdGetPropertyCount)
        case respGetPropCount(RespGetPropertyCount)
        case cmdGetPropVals(CmdGetPropertyValues)
        case respGetPropVals(RespGetPropertyValues)
        case cmdSetPropVals(CmdSetPropertyValues)
        case respSetPropVals(RespSetPropertyValues)

        #if !swift(>=4.1)
            static func == (lhs: LocalCtrlMessage.OneOf_Payload, rhs: LocalCtrlMessage.OneOf_Payload) -> Bool {
                switch (lhs, rhs) {
                case let (.cmdGetPropCount(l), .cmdGetPropCount(r)): return l == r
                case let (.respGetPropCount(l), .respGetPropCount(r)): return l == r
                case let (.cmdGetPropVals(l), .cmdGetPropVals(r)): return l == r
                case let (.respGetPropVals(l), .respGetPropVals(r)): return l == r
                case let (.cmdSetPropVals(l), .cmdSetPropVals(r)): return l == r
                case let (.respSetPropVals(l), .respSetPropVals(r)): return l == r
                default: return false
                }
            }
        #endif
    }

    init() {}

    private var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension LocalCtrlMsgType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "TypeCmdGetPropertyCount"),
        1: .same(proto: "TypeRespGetPropertyCount"),
        4: .same(proto: "TypeCmdGetPropertyValues"),
        5: .same(proto: "TypeRespGetPropertyValues"),
        6: .same(proto: "TypeCmdSetPropertyValues"),
        7: .same(proto: "TypeRespSetPropertyValues"),
    ]
}

extension CmdGetPropertyCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "CmdGetPropertyCount"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CmdGetPropertyCount, rhs: CmdGetPropertyCount) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension RespGetPropertyCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "RespGetPropertyCount"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .same(proto: "count"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &status)
            case 2: try decoder.decodeSingularUInt32Field(value: &count)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if status != .success {
            try visitor.visitSingularEnumField(value: status, fieldNumber: 1)
        }
        if count != 0 {
            try visitor.visitSingularUInt32Field(value: count, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: RespGetPropertyCount, rhs: RespGetPropertyCount) -> Bool {
        if lhs.status != rhs.status { return false }
        if lhs.count != rhs.count { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PropertyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "PropertyInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .same(proto: "name"),
        3: .same(proto: "type"),
        4: .same(proto: "flags"),
        5: .same(proto: "value"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &status)
            case 2: try decoder.decodeSingularStringField(value: &name)
            case 3: try decoder.decodeSingularUInt32Field(value: &type)
            case 4: try decoder.decodeSingularUInt32Field(value: &flags)
            case 5: try decoder.decodeSingularBytesField(value: &value)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if status != .success {
            try visitor.visitSingularEnumField(value: status, fieldNumber: 1)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 2)
        }
        if type != 0 {
            try visitor.visitSingularUInt32Field(value: type, fieldNumber: 3)
        }
        if flags != 0 {
            try visitor.visitSingularUInt32Field(value: flags, fieldNumber: 4)
        }
        if !value.isEmpty {
            try visitor.visitSingularBytesField(value: value, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PropertyInfo, rhs: PropertyInfo) -> Bool {
        if lhs.status != rhs.status { return false }
        if lhs.name != rhs.name { return false }
        if lhs.type != rhs.type { return false }
        if lhs.flags != rhs.flags { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CmdGetPropertyValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "CmdGetPropertyValues"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "indices"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedUInt32Field(value: &indices)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !indices.isEmpty {
            try visitor.visitPackedUInt32Field(value: indices, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CmdGetPropertyValues, rhs: CmdGetPropertyValues) -> Bool {
        if lhs.indices != rhs.indices { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension RespGetPropertyValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "RespGetPropertyValues"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .same(proto: "props"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &status)
            case 2: try decoder.decodeRepeatedMessageField(value: &props)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if status != .success {
            try visitor.visitSingularEnumField(value: status, fieldNumber: 1)
        }
        if !props.isEmpty {
            try visitor.visitRepeatedMessageField(value: props, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: RespGetPropertyValues, rhs: RespGetPropertyValues) -> Bool {
        if lhs.status != rhs.status { return false }
        if lhs.props != rhs.props { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "PropertyValue"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "index"),
        2: .same(proto: "value"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &index)
            case 2: try decoder.decodeSingularBytesField(value: &value)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if index != 0 {
            try visitor.visitSingularUInt32Field(value: index, fieldNumber: 1)
        }
        if !value.isEmpty {
            try visitor.visitSingularBytesField(value: value, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PropertyValue, rhs: PropertyValue) -> Bool {
        if lhs.index != rhs.index { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CmdSetPropertyValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "CmdSetPropertyValues"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "props"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &props)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !props.isEmpty {
            try visitor.visitRepeatedMessageField(value: props, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CmdSetPropertyValues, rhs: CmdSetPropertyValues) -> Bool {
        if lhs.props != rhs.props { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension RespSetPropertyValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "RespSetPropertyValues"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &status)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if status != .success {
            try visitor.visitSingularEnumField(value: status, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: RespSetPropertyValues, rhs: RespSetPropertyValues) -> Bool {
        if lhs.status != rhs.status { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension LocalCtrlMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "LocalCtrlMessage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "msg"),
        10: .standard(proto: "cmd_get_prop_count"),
        11: .standard(proto: "resp_get_prop_count"),
        12: .standard(proto: "cmd_get_prop_vals"),
        13: .standard(proto: "resp_get_prop_vals"),
        14: .standard(proto: "cmd_set_prop_vals"),
        15: .standard(proto: "resp_set_prop_vals"),
    ]

    fileprivate class _StorageClass {
        var _msg: LocalCtrlMsgType = .typeCmdGetPropertyCount
        var _payload: LocalCtrlMessage.OneOf_Payload?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _msg = source._msg
            _payload = source._payload
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularEnumField(value: &_storage._msg)
                case 10:
                    var v: CmdGetPropertyCount?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .cmdGetPropCount(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .cmdGetPropCount(v) }
                case 11:
                    var v: RespGetPropertyCount?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .respGetPropCount(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .respGetPropCount(v) }
                case 12:
                    var v: CmdGetPropertyValues?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .cmdGetPropVals(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .cmdGetPropVals(v) }
                case 13:
                    var v: RespGetPropertyValues?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .respGetPropVals(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .respGetPropVals(v) }
                case 14:
                    var v: CmdSetPropertyValues?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .cmdSetPropVals(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .cmdSetPropVals(v) }
                case 15:
                    var v: RespSetPropertyValues?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .respSetPropVals(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .respSetPropVals(v) }
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if _storage._msg != .typeCmdGetPropertyCount {
                try visitor.visitSingularEnumField(value: _storage._msg, fieldNumber: 1)
            }
            switch _storage._payload {
            case let .cmdGetPropCount(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            case let .respGetPropCount(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            case let .cmdGetPropVals(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            case let .respGetPropVals(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
            case let .cmdSetPropVals(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
            case let .respSetPropVals(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: LocalCtrlMessage, rhs: LocalCtrlMessage) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._msg != rhs_storage._msg { return false }
                if _storage._payload != rhs_storage._payload { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
